% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/unsupSaturation.R
\name{unsupSaturation}
\alias{unsupSaturation}
\title{Unsupervised Classification Saturation Function}
\usage{
unsupSaturation(raster, nSamples, nClasses, nStarts, valData, responseCol,
  valSamples)
}
\arguments{
\item{raster}{A raster file.}

\item{nSamples}{Integer. Number of random samples to draw to fit cluster map.}

\item{nClasses}{Vector of integers, containing the number of classes.}

\item{nStarts}{Integer. Number of random starts for kmeans algorithm.}

\item{valData}{SpatialPolygonsDataFrame or SpatialPointsDataFrame with validation data.}

\item{responseCol}{Character. Column containing the validation data in attribute table of valData.}

\item{valSamples}{Integer. Number of pixels to sample for validation (only applies to polygons).}
}
\value{
A list containing:
\itemize{
  \item Raster. The output image of the best unsupervised classification containing the presence
  probability of the desired class' presence.
  \item Data.Frame. Overall accuracies for each class number.
  \item Classificaation metrics for the best unsupervised classification.
}
}
\description{
This function aims to identify the number of classes required for an unsupervised
classification in order to get the highest accuracy results when mapping the
distribution of a single class.
}
\details{
The output images contains values ranging from 1 - 4. These pixel values represent:
\itemize{
  \item 1 - High probability
  \item 2 - Medium probability
  \item 3 - Low probability
  \item 4 - Least probability
}
}
\examples{
library(sp)
library(raster)
library(RStoolbox)
library(ggplot2)

# Load sample raster file
my_raster <- raster::brick(system.file(package = "unsuperClassAnalysis",
                           "extdata", "landsat_sample.tif"))

# Load sample validation data
my_val <- raster::shapefile(system.file(package = "unsuperClassAnalysis", "extdata",
                            "validation_sample.shp"))

# Get vector of class name for each polygon and check if it matches with "deforest"
# If there's a match it will return 1, else it will return NA
deforest_vec <- match(my_val@data[,2], "deforest")

# Replace all NAs with 0
deforest_vec[is.na(deforest_vec)] <- 0

# Add new binary vector as new column in shapefile
# Now every polygon has a binary code whether it's deforested area (1) or not (0)
my_val[["Unsup_Id"]] <- deforest_vec

# Plot raster data with validation data on top
raster::plotRGB(my_raster, 3,2,1, stretch="lin")
plot(my_val[my_val$Unsup_Id == 0,], col="red", add=T)
plot(my_val[my_val$Unsup_Id == 1,], col="blue", add=T)

# Execute function
x <- unsupSaturation(raster = my_raster,
                    nSamples = 1000,
                    nClasses = c(2,3,5,10),
                    nStarts = 25,
                    valData = my_val,
                    responseCol = "Unsup_Id",
                    valSamples = 1000)

# Get best unsupervised classification
x1 <- x[[1]]

# Get data.frame with accuracy statistics
x2 <- x[[2]]

# Get accuracy matrix of best classification
x3 <- x[[3]]

# Get unique values of classification
unique_vals <- unique(x1)

# Change numeric (continuous) values to factor (discrete) for discrete legend
x1[] <- as.factor(x1@data@values)

# Plot with ggplot
RStoolbox::ggR(x1, geom_raster = T)+
 ggtitle("Unsupervised Classification of Deforested Areas\\n")+
 theme(plot.title = element_text(hjust = 0.5, face="bold", size=14))+
 theme(legend.title = element_text(size = 11, face = "bold"))+
 theme(legend.text = element_text(size = 10))+
 scale_fill_manual(values = c("red", "khaki", "beige"),
                   labels = c("High", "Medium", "Least"),
                   name = "Deforestation\\nProbability")+
 xlab("")+
 ylab("")

}
